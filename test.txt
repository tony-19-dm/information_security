import random
import os
from lab1 import fast_pow, ferm_test, extended_gcd

def Shamir(p, m, Ca, Da, Cb, Db):
    print(f"Исходное сообщение: m = {m}")
    
    x1 = fast_pow(m, Ca, p)
    print(f"Шаг 1: x1 = {m}^{Ca} mod {p} = {x1}")
    
    x2 = fast_pow(x1, Cb, p)
    print(f"Шаг 2: x2 = {x1}^{Cb} mod {p} = {x2}")
    
    x3 = fast_pow(x2, Da, p)
    print(f"Шаг 3: x3 = {x2}^{Da} mod {p} = {x3}")
    
    x4 = fast_pow(x3, Db, p)
    print(f"Шаг 4: x4 = {x3}^{Db} mod {p} = {x4}")
    
    if x4 == m:
        print(f"Сообщение корректно расшифровано: {x4}")
    else:
        print(f"Ошибка! Получено: {x4}, ожидалось: {m}")
    
    return x4

def shamir_encrypt_file(input_file, output_file, p, Ca, Cb):
    """
    Шифрование файла по протоколу Шамира
    """
    print(f"Шифрование файла: {input_file} -> {output_file}")
    
    with open(input_file, 'rb') as f_in, open(output_file, 'wb') as f_out:
        # Читаем файл побайтово
        data = f_in.read()
        
        # Шифруем каждый байт
        encrypted_data = bytearray()
        for byte in data:
            # Шаг 1: A -> B: x1 = m^Ca mod p
            x1 = fast_pow(byte, Ca, p)
            # Шаг 2: B -> A: x2 = x1^Cb mod p
            x2 = fast_pow(x1, Cb, p)
            
            # Сохраняем зашифрованный байт (берем младший байт результата)
            encrypted_byte = x2 % 256
            encrypted_data.append(encrypted_byte)
        
        f_out.write(encrypted_data)
    
    print(f"Файл успешно зашифрован. Размер: {len(encrypted_data)} байт")

def shamir_decrypt_file(input_file, output_file, p, Da, Db):
    """
    Расшифрование файла по протоколу Шамира
    """
    print(f"Расшифрование файла: {input_file} -> {output_file}")
    
    with open(input_file, 'rb') as f_in, open(output_file, 'wb') as f_out:
        # Читаем зашифрованный файл
        encrypted_data = f_in.read()
        
        # Расшифровываем каждый байт
        decrypted_data = bytearray()
        for encrypted_byte in encrypted_data:
            # Шаг 3: A -> B: x3 = x2^Da mod p
            x3 = fast_pow(encrypted_byte, Da, p)
            # Шаг 4: B -> A: x4 = x3^Db mod p
            x4 = fast_pow(x3, Db, p)
            
            # Восстанавливаем исходный байт
            decrypted_byte = x4 % 256
            decrypted_data.append(decrypted_byte)
        
        f_out.write(decrypted_data)
    
    print(f"Файл успешно расшифрован. Размер: {len(decrypted_data)} байт")

def generate_shamir_keys(p):
    """
    Генерация ключей для протокола Шамира
    """
    # Генерация ключей для Алисы
    while True:
        Ca = random.randint(2, p-2)
        res = extended_gcd(Ca, p - 1)
        if res[0] == 1:
            break
    
    Da = res[1]
    if Da < 0:
        Da += (p - 1)
    
    # Генерация ключей для Боба
    while True:
        Cb = random.randint(2, p-2)
        res = extended_gcd(Cb, p - 1)
        if res[0] == 1:
            break
    
    Db = res[1]
    if Db < 0:
        Db += (p - 1)
    
    return Ca, Da, Cb, Db

def file_operations():
    """
    Функция для работы с файлами
    """
    print("\n=== РЕЖИМ РАБОТЫ С ФАЙЛАМИ ===")
    print("1. Шифрование файла")
    print("2. Расшифрование файла")
    choice = input("Выберите действие (1/2): ").strip()
    
    # Генерация или ввод параметров
    print("\nГенерация параметров:")
    while True:
        p = random.randint(100000, 1000000)
        if ferm_test(p):
            break
    print(f"Сгенерировано простое число p = {p}")
    
    Ca, Da, Cb, Db = generate_shamir_keys(p)
    print(f"Ключи Алисы: Ca = {Ca}, Da = {Da}")
    print(f"Ключи Боба: Cb = {Cb}, Db = {Db}")
    
    if choice == '1':
        # Шифрование
        input_file = input("Введите путь к файлу для шифрования: ").strip()
        if not os.path.exists(input_file):
            print("Файл не найден!")
            return
        
        output_file = input("Введите путь для сохранения зашифрованного файла: ").strip()
        
        shamir_encrypt_file(input_file, output_file, p, Ca, Cb)
        print(f"\nДля расшифрования используйте ключи:")
        print(f"p = {p}")
        print(f"Da = {Da}")
        print(f"Db = {Db}")
        
    elif choice == '2':
        # Расшифрование
        input_file = input("Введите путь к зашифрованному файлу: ").strip()
        if not os.path.exists(input_file):
            print("Файл не найден!")
            return
        
        output_file = input("Введите путь для сохранения расшифрованного файла: ").strip()
        
        # Можно использовать автоматически сгенерированные ключи или ввести свои
        use_generated = input("Использовать сгенерированные ключи? (y/n): ").strip().lower()
        if use_generated == 'n':
            Da = int(input("Введите Da: "))
            Db = int(input("Введите Db: "))
        
        shamir_decrypt_file(input_file, output_file, p, Da, Db)
    
    else:
        print("Неверный выбор!")

def main():
    print("Выберите режим работы:")
    print("1. Демонстрация протокола Шамира с числами")
    print("2. Работа с файлами (шифрование/расшифрование)")
    
    mode = input("Выберите режим (1/2): ").strip()
    
    if mode == '1':
        print("Ввести числа вручную? (y/n): ")
        
        ans = input().strip().lower()
        
        if ans == 'y':
            while True:
                p = int(input("p (простое число) = "))
                if ferm_test(p):
                    break
                else:
                    print("p - не простое, введите повторно")

            while True:
                m = int(input("m = "))
                if m < p:
                    break
                else:
                    print("m должно быть меньше p")
            
            while True:
                Ca = int(input("Ca = "))
                res = extended_gcd(Ca, p - 1)
                if res[0] == 1:
                    break
                else:
                    print("Ca должно быть взаимно простым с p - 1")

            while True:
                Da = int(input("Da = "))
                if Ca * Da % (p - 1) == 1:
                    break
                else:
                    print("Da должно быть взаимно обратным с Ca")

            while True:
                Cb = int(input("Cb = "))
                res = extended_gcd(Cb, p - 1)
                if res[0] == 1:
                    break
                else:
                    print("Cb должно быть взаимно простым с p - 1")

            while True:
                Db = int(input("Db = "))
                if Cb * Db % (p - 1) == 1:
                    break
                else:
                    print("Db должно быть взаимно обратным с Cb")

            Shamir(p, m, Ca, Da, Cb, Db)
            
        elif ans == 'n':
            while True:
                p = random.randint(1000000, 100000000)
                if ferm_test(p):
                    break
            print(f"p = {p}")
            
            m = random.randint(1, p-1)
            print(f"m = {m}")
            
            while True:
                Ca = random.randint(2, p-2)
                res = extended_gcd(Ca, p - 1)
                if res[0] == 1:
                    break
            
            Da = res[1]
            if Da < 0:
                Da += (p - 1)
            print(f"Ca = {Ca}, Da = {Da}")
            
            while True:
                Cb = random.randint(2, p-2)
                res = extended_gcd(Cb, p - 1)
                if res[0] == 1:
                    break
            
            Db = res[1]
            if Db < 0:
                Db += (p - 1)
            print(f"Cb = {Cb}, Db = {Db}")

            Shamir(p, m, Ca, Da, Cb, Db)
        
        else:
            print("Неверный ввод")
    
    elif mode == '2':
        file_operations()
    
    else:
        print("Неверный выбор режима!")

if __name__ == "__main__":
    main()